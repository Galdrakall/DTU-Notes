
These practice problems have the purpose of helping you understand the material better and
learning the skills that are necessary to analyze cryptographic constructions, and sometimes to
prepare you for the next class. All answers should be supported by a written justification. To
gauge whether a justification is sufficient, ask yourself if your peers would be convinced by it
without additional explanations.

---

## Exercise 1. (Secure digital signatures for messages of arbitrary length)

In the lecture you saw a proof sketch how RSA signatures for arbitrary-length messages are
constructed. Because plain RSA signatures are not secure, not even for fixed-length messages,
we had to use the Random Oracle Model (ROM). As it turns out, the ROM is not necessary
when using a hash function and a secure digital signature scheme (DSS) to construct a DSS
for arbitrary-length messages.

Assume that  
$\Sigma = (\Sigma.\text{KeyGen}, \Sigma.\text{Sign}, \Sigma.\text{Ver})$  
is a secure DSS for messages of length $n$ bits. Furthermore, assume that $H$ is a
collision-resistant hash function mapping $\{0, 1\}^* \to \{0, 1\}^n$.

1. Construct a signature scheme which can sign messages from $\{0, 1\}^*$, using the given
   signature scheme and $H$, following the idea of RSA-FDH.

2. Show that your constructed signature scheme is **EUF-CMA secure**, given that $\Sigma$
   is secure and $H$ is collision-resistant.

---

## Exercise 2. (Non-Repudiation)

In the lecture, it was mentioned that secure DSS have the non-repudiation property. Here, we
explore this property a bit more explicitly.

1. Show that the following holds:  
   Assume that a signer uses a digital signature scheme $\Sigma$, has generated a public key
   $vk$ for it but never releases the signing key $sk$ to anyone. Furthermore, assume that
   there exists an efficient algorithm $\mathcal{A}$ which generates a valid signature
   verifiable under $vk$ that was never generated by the signer (i.e. the signature scheme
   does not provide non-repudiation). Then $\mathcal{A}$ can be used to efficiently
   distinguish $L_{\text{sig−real}}$ and $L_{\text{sig−fake}}$ for the digital signature
   scheme.

2. Why does the same argument not apply for a single message sender in a MAC scheme,
   even though its security is essentially defined in the same way?

---

## Exercise 3. (Why we need hashes for RSA signatures)

It might be tempting to design RSA signatures without using a cryptographic hash function
$H$. The idea could be the following, alternative signing algorithm:

1. The input is a message $m \in \mathbb{Z}_N^*$ such that  
   $m < \lfloor N / 2^{16} \rfloor$ (i.e. the first two bytes of $m$ are 00).

2. We then sign this $m$ by computing  
   $$
   \sigma = m^d \bmod N.
   $$

For verification, we now do the following:

1. Check that the message $m \in \mathbb{Z}_N^*$ is of the correct form, namely that it is
   smaller than $\lfloor N / 2^{16} \rfloor$.

2. Check that  
   $$
   \sigma^e = m \bmod N.
   $$

Let us assume that raising to the $e$-th power modulo $N$ is a perfect permutation, i.e. on
input $x \in \mathbb{Z}_N^*$ the value $x^e \bmod N$ is uniformly random in
$\mathbb{Z}_N^*$. Show that an attacker, by only using the public key $pk$, can break the
EUF-CMA property for the aforementioned “signature” scheme by making around
$2^{16}$ exponentiations modulo $N$.

---

## Exercise 4. (Hashing to $\mathbb{Z}_N^*$)

In the lecture, we assumed that the hash function $H$ used in the RSA-FDH construction
outputs a value in $\mathbb{Z}_N^*$ for every message $m$. It might appear unrealistic to
construct such a hash function, because this is a very specific requirement on the output set.

Show that using a hash function $\hat{H}$ which outputs random values from
$\mathbb{Z}_N$ instead of $\mathbb{Z}_N^*$ is sufficient for the task.

To do so, assume that $p, q$ are both of size around $2^{1000}$ (i.e. 1000 bits long), and
calculate how many outputs of $\hat{H}$ will lie outside of $\mathbb{Z}_N^*$ by not being
coprime to $N$. To do so, you can count the total number of integers in $[0, N - 1]$ that are
not coprime to $N$ in a clever way.

**Bonus:**  
Assume that $\hat{H}$ is outputting values in
$\mathbb{Z}_N \setminus (\mathbb{Z}_N^* \cup \{0\})$ with a high probability over its possible
inputs. Show that you can use it to factor $N$ efficiently with essentially the same
probability.

---

# Problem Sheet 9 – Full Step-by-Step Solutions

This section contains full derivations and explanations for each exercise.

---

# Exercise 1 – Secure signatures for arbitrary-length messages

We are given a secure DSS
$$
\Sigma = (\Sigma.\text{KeyGen}, \Sigma.\text{Sign}, \Sigma.\text{Ver})
$$
for fixed-length messages in $\{0,1\}^n$, and a collision-resistant hash function
$$
H : \{0,1\}^* \to \{0,1\}^n.
$$

## 1. Construction (hash-then-sign)

Define a new scheme $\Sigma' = (\Sigma'.\text{KeyGen}, \Sigma'.\text{Sign}, \Sigma'.\text{Ver})$ for arbitrary-length messages $m \in \{0,1\}^*$ as follows:

- **KeyGen:**
  - Run $\Sigma.\text{KeyGen}$ to obtain $(vk,sk)$.
  - Output $(vk',sk') = (vk,sk)$ (reuse the same keys).

- **Sign:** on input $(sk',m)$ with $m \in \{0,1\}^*$:
  1. Compute $h := H(m) \in \{0,1\}^n$.
  2. Compute $\sigma := \Sigma.\text{Sign}(sk,h)$.
  3. Output signature $\sigma$.

- **Verify:** on input $(vk',m,\sigma)$:
  1. Compute $h := H(m)$.
  2. Output $\Sigma.\text{Ver}(vk,h,\sigma)$.

This is the standard "hash-then-sign" construction analogous to RSA-FDH.

## 2. EUF-CMA security of $\Sigma'$ from $\Sigma$ and $H$

We show that if $\Sigma'$ were not EUF-CMA secure, then we could either

1. break EUF-CMA security of $\Sigma$, or
2. find a collision for $H$.

Let $\mathcal{A}$ be a PPT adversary that forges signatures for $\Sigma'$ in the EUF-CMA game. That means:

- $\mathcal{A}$ gets $vk'$ and access to a signing oracle for $\Sigma'$ on messages $m \in \{0,1\}^*$.
- Eventually, $\mathcal{A}$ outputs $(m^*,\sigma^*)$ such that
  - $\Sigma'.\text{Ver}(vk',m^*,\sigma^*)=1$ and
  - $m^*$ was never queried to the signing oracle.

Let $Q$ be the set of messages queried to the $\Sigma'$-signing oracle.

### Hybrid reduction

We construct a reduction $\mathcal{B}$ that plays the EUF-CMA game for $\Sigma$ and uses $\mathcal{A}$ as a subroutine.

Game for $\Sigma$:

- Challenger gives $vk$ to $\mathcal{B}$ and answers signing queries on messages $h \in \{0,1\}^n$ by returning $\Sigma.\text{Sign}(sk,h)$.

Reduction $\mathcal{B}$ simulates the $\Sigma'$ game for $\mathcal{A}$ as follows:

1. Receive $vk$ and set $vk' = vk$.
2. On a signing query $m$ from $\mathcal{A}$:
   - Compute $h := H(m)$.
   - Query the $\Sigma$ signing oracle on $h$ to obtain $\sigma$.
   - Return $\sigma$ to $\mathcal{A}$.
3. Eventually $\mathcal{A}$ outputs a forgery $(m^*,\sigma^*)$ with $m^* \notin Q$ and $\Sigma'.\text{Ver}(vk',m^*,\sigma^*)=1$.

Then $\mathcal{B}$ computes $h^* := H(m^*)$ and considers $(h^*,\sigma^*)$ as a candidate forgery for $\Sigma$.

Two cases:

1. **Case 1: $h^*$ never appeared as a hash of a queried message.**

   That is, $h^* \ne H(m)$ for all $m \in Q$. Then $\mathcal{B}$ never asked its signing oracle for $h^*$.

   - Since $\Sigma'.\text{Ver}(vk',m^*,\sigma^*)=1$, we have $\Sigma.\text{Ver}(vk,h^*,\sigma^*)=1$.
   - Because $h^*$ was never queried to the signing oracle, $(h^*,\sigma^*)$ is a valid EUF-CMA forgery for $\Sigma$.

   Thus in this case $\mathcal{B}$ breaks the security of $\Sigma$.

2. **Case 2: $h^* = H(m)$ for some $m \in Q$.**

   Since $m^* \notin Q$ but $H(m^*) = H(m)$ for some $m \in Q$, we have found a **collision** for $H$:
   $$m \ne m^*, \quad H(m) = H(m^*).$$

Since $H$ is assumed collision resistant, the probability of Case 2 must be negligible. Therefore, with non-negligible probability we are in Case 1, and $\mathcal{B}$ produces a successful forgery against $\Sigma$.

Hence, if $\Sigma'$ were not EUF-CMA secure, then either $\Sigma$ is not EUF-CMA secure or $H$ is not collision-resistant. Contrapositively, if $\Sigma$ is EUF-CMA secure and $H$ is collision-resistant, then $\Sigma'$ is EUF-CMA secure.

---

# Exercise 2 – Non-repudiation

## 1. From non-repudiation failure to breaking sig-real/sig-fake

Suppose we have a signer who keeps $sk$ secret and only ever produces signatures using $\Sigma.\text{Sign}(sk,\cdot)$. Assume there exists a PPT algorithm $\mathcal{A}$ that on input only the verification key $vk$ outputs a valid signature $\sigma$ on some message $m$ **that the signer never signed**.

We show how to distinguish the real vs fake signature libraries $L_{\text{sig-real}}$ and $L_{\text{sig-fake}}$ using $\mathcal{A}$.

Intuitively:

- In $L_{\text{sig-real}}$, every valid signature must come from the signer (who alone knows $sk$).
- In $L_{\text{sig-fake}}$, signatures are generated in an idealized way, e.g. some outputs may not correspond to any signer’s activity.

Distinguishing strategy:

1. Given access to a library $L$ that is either $L_{\text{sig-real}}$ or $L_{\text{sig-fake}}$, first obtain $vk$ from $L$.
2. Run $\mathcal{A}(vk)$ to produce a pair $(m_*,\sigma_*)$ such that $\Sigma.\text{Ver}(vk,m_*,\sigma_*) = 1$ and $(m_*,\sigma_*)$ was never output by the signer.
3. Check whether $(m_*,\sigma_*)$ appears among the signatures produced by $L$:
   - If it never appears but still verifies, output "fake".
   - If it does appear as an oracle output, output "real".

Because in the real library valid signatures are exactly those produced by the signer, while $\mathcal{A}$ can generate a fresh valid signature not from the signer, this behavior distinguishes the two libraries with non-negligible advantage.

Thus, a violation of non-repudiation gives a distinguisher between $L_{\text{sig-real}}$ and $L_{\text{sig-fake}}$.

## 2. Why the same argument does not apply to MACs

For MAC schemes, the verification key and the MAC key are **the same secret key** shared between sender and receiver. Any party who can verify tags (MACs) can also **forge** them. Therefore:

- If a receiver presents a valid MAC $(m,\tau)$, the sender cannot tell whether the receiver generated it or the sender did.
- There is no notion of "uniquely attributable" tags, since all parties with the key are equally capable of producing valid tags.

The non-repudiation argument for signatures hinges on the fact that only the signer knows $sk$, but verification is public. For MACs, anyone who can verify can also forge, so a receiver can always generate valid tags and later claim they came from the sender. Hence the sig-real/sig-fake distinguishing argument does **not** translate to MACs.

---

# Exercise 3 – Why we need hashes for RSA signatures

We consider the toy RSA signing scheme without hashing:

- Message space: $m \in \mathbb{Z}_N^*$ with $m < \lfloor N / 2^{16} \rfloor$,
- Signing: $\sigma = m^d \bmod N$,
- Verification: check $m < \lfloor N / 2^{16} \rfloor$ and $\sigma^e \equiv m \pmod N$.

Assume that exponentiation by $e$ modulo $N$ acts as a "perfect permutation" on $\mathbb{Z}_N^*$, i.e. for random $x$ the value $x^e \bmod N$ is uniformly random in $\mathbb{Z}_N^*$.

We show how an attacker can break EUF-CMA with about $2^{16}$ exponentiations.

## Attack idea

The verifier only accepts messages in the subset
$$
M := \{ m \in \mathbb{Z}_N^* : m < \lfloor N / 2^{16} \rfloor \},
$$
which is roughly a $1/2^{16}$ fraction of $\mathbb{Z}_N^*$.

The attacker wants to find **some** message $m \in M$ and a corresponding signature $\sigma$ such that $\sigma^e \equiv m \pmod N$, without using the signing key.

Because exponentiation by $e$ is a permutation, for any $\sigma \in \mathbb{Z}_N^*$ the value $m = \sigma^e \bmod N$ is uniformly random in $\mathbb{Z}_N^*$. Therefore the probability that $m$ lands in $M$ is approximately
$$
\Pr[m \in M] \approx \frac{|M|}{|\mathbb{Z}_N^*|} \approx \frac{1}{2^{16}}.
$$

Hence, by sampling random $\sigma$'s and computing $m = \sigma^e \bmod N$, the attacker obtains valid-looking pairs $(m,\sigma)$, and with probability about $1/2^{16}$ each trial produces an $m$ satisfying the "first two bytes are 00" condition.

## Concrete attack

1. Repeat the following for about $2^{16}$ iterations:
   - Pick a random $\sigma \leftarrow \mathbb{Z}_N^*$.
   - Compute $m := \sigma^e \bmod N$.
   - Check whether $m < \lfloor N / 2^{16} \rfloor$.
2. As soon as such an $m$ is found, output $(m,\sigma)$ as a forged message-signature pair.

Because $\sigma^e \equiv m \pmod N$ by construction and $m$ falls in the allowed message set, $(m,\sigma)$ passes the verification algorithm with probability 1, yet no signing key was used.

The expected number of trials to hit $M$ is roughly $2^{16}$, so the overall attack cost is about $2^{16}$ exponentiations, as claimed. Thus, without hashing, this naive RSA scheme is not EUF-CMA secure.

---

# Exercise 4 – Hashing to $\mathbb{Z}_N^*$

We want a hash function $H$ whose outputs always lie in $\mathbb{Z}_N^*$ (i.e. are coprime to $N$), but implementing that exactly seems restrictive. Instead, suppose we have a hash function
$$
\hat{H} : \{0,1\}^* \to \mathbb{Z}_N
$$
whose outputs are (close to) uniformly distributed over $\{0,1,\dots,N-1\}$.

We show that using $\hat{H}$ is sufficient, because the fraction of outputs not in $\mathbb{Z}_N^*$ is negligible.

Let $N = pq$ with $p,q$ prime, each about 1000 bits (so $p \approx q \approx 2^{1000}$, $N \approx 2^{2000}$).

## Counting non-coprime outputs

An integer $x \in \{0,1,\dots,N-1\}$ is **not** in $\mathbb{Z}_N^*$ iff it shares a nontrivial factor with $N$, i.e. iff $p \mid x$ or $q \mid x$.

Count such $x$ using inclusion–exclusion:

- Multiples of $p$ in $[0,N-1]$: there are exactly $q$ of them: $0,p,2p,\dots,(q-1)p$.
- Multiples of $q$ in $[0,N-1]$: there are exactly $p$ of them.
- Multiples of both $p$ and $q$ are multiples of $N = pq$; in $[0,N-1]$ this is only $0$.

Therefore, the total number of integers in $[0,N-1]$ that are not coprime to $N$ is
$$
q + p - 1.
$$

The total number of elements in $\mathbb{Z}_N$ is $N$. So the fraction of non-coprime elements is
$$
\frac{p+q-1}{N}.
$$
Since $p,q \approx 2^{1000}$ and $N \approx 2^{2000}$, we have roughly
$$
\frac{p+q-1}{N} \approx \frac{2^{1000} + 2^{1000}}{2^{2000}} = 2\cdot 2^{-1000} = 2^{-999},
$$
which is astronomically small.

Thus, if $\hat{H}$ outputs are uniform in $\mathbb{Z}_N$, then with probability about $1 - 2^{-999}$ the output lies in $\mathbb{Z}_N^*$. In practice, one can simply:

- compute $y = \hat{H}(m)$,
- if $\gcd(y,N) \ne 1$, either reject and re-hash with a different salt/label, or map $y$ to a nearby coprime value.

The probability of rejection is negligible.

## Bonus – Using "bad" outputs to factor $N$

Assume now that $\hat{H}$ outputs values in
$$
\mathbb{Z}_N \setminus (\mathbb{Z}_N^* \cup \{0\})
$$
with high probability. That means it often outputs values $y$ such that

- $y \ne 0$, and
- $\gcd(y,N) \ne 1$ (i.e. $y$ shares a nontrivial factor with $N$).

Given such a $y$, we can factor $N$ efficiently:

1. Compute $g = \gcd(y,N)$ using the Euclidean algorithm.
2. Since $y$ is not coprime to $N$ and not 0, $g$ is a nontrivial divisor of $N$, i.e. $g$ is either $p$ or $q$.
3. Set $p = g$ and $q = N/g$ to factor $N$.

Thus, if one could generate such "bad" hash outputs with high probability over inputs, one would obtain a factoring algorithm with essentially the same success probability. This shows that if $\hat{H}$ frequently outputs non-coprime values, then $N$ can be factored efficiently, which contradicts the assumed hardness of factoring. In practice, therefore, we expect $\hat{H}$ to output values in $\mathbb{Z}_N^*$ with overwhelming probability and can safely use it as a stand-in for a hash into $\mathbb{Z}_N^*$.

